/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

//recursive
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        Queue <Integer>  q1 = new LinkedList<>();
        Queue <Integer>  q2 = new LinkedList<>();

        List<Integer> res = new ArrayList<>();


        inOrder(root1, q1);
        inOrder(root2, q2);

        while(q1.size()>0 || q2.size()>0){
            if(q1.size() < 1){
                res.add(q2.peek());
                q2.poll();
            }else if(q2.size()<1){
                res.add(q1.peek());
                q1.poll();
            }else{
                if(q1.peek() < q2.peek()){
                    res.add(q1.peek());
                    q1.poll();
                }else{
                    res.add(q2.peek());
                    q2.poll();
                }
            }


        }
        return res;

    }

    public void inOrder(TreeNode root, Queue<Integer> q){
        if(root == null){
            return;
        }

        inOrder(root.left,q);
        q.add(root.val);
        inOrder(root.right,q);
    }
}




Complexity Analysis

Time complexity: O(N+M), where M and N are node numbers. It's one-pass approach along each tree.

Space complexity: O(N+M) to keep the output and both stacks. 
//Iterative
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        Stack<TreeNode> s1 = new Stack();
        Stack<TreeNode> s2 = new Stack<>();

        TreeNode c1 = root1;
        TreeNode c2 = root2;

        List<Integer> res = new LinkedList<>();

        while(c1!= null || c2 != null || !s1.isEmpty() || !s2.isEmpty()){
            while( c1 != null){
                s1.push(c1);
                c1 = c1.left;
            }

            while(c2 != null){
                s2.push(c2);
                c2 = c2.left;
            }

            if(!s2.isEmpty() && !s1.isEmpty()){
                if(s1.peek().val > s2.peek().val){
                    res.add(s2.peek().val);
                    c2= s2.peek().right;
                    s2.pop();
                }else{
                    res.add(s1.peek().val);
                    c1= s1.peek().right;
                    s1.pop();
                }
            }else{
                if(s1.isEmpty()&& !s2.isEmpty()){
                    res.add(s2.peek().val);
                    c2=s2.peek().right;
                    s2.pop();
                }else if(s2.isEmpty()&& !s1.isEmpty()){
                    res.add(s1.peek().val);
                    c1=s1.peek().right;
                    s1.pop();
                }
            }
        }
        return res;
    }
}


