package test;

import java.util.PriorityQueue;
import java.util.Queue;

//215. Kth Largest Element in an Array
//leetcode
//使用quick sort 的方法， 首先选出比较的PV 点， 一般PV 选的是最右边的点， 然后比较，把小于pv 的都移到左边，然后重复这个步骤
public class findKthLargest {

	/*
	public int findKthLargest(int[] nums, int k) {
		if (nums.length == 0 || nums == null) {
			return 0;
		}
		return kth(nums, 0, nums.length - 1, nums.length - k);
	}

	public void swap(int m, int n, int[] nums) {
		int tmp = nums[m];
		nums[m] = nums[n];
		nums[n] = tmp;
	}

	public int kth(int[] nums, int left, int right, int index) {
		//检查越界条件
		if (left > right) {
			return 0;
		}
		//pv选的最右边的点
		int pv = nums[right];
		int star = left;
		//好好记住这个交换的步骤， 把小于pv 都移到左边, 
		for (int j = left; j < right; j++) {
			if (nums[j] <= pv) {
				swap(star++, j, nums);
			}
		}
		swap(right, star, nums);
        
		//重复这个步骤，一直到选中的那个刚好是K
		if (index == star) {
			return nums[star];
		} else if (index > star) {
			return kth(nums, star + 1, right, index);
		} else {
			return kth(nums, left, star - 1, index);
		}

	}
	
/*	O(log(n)) time for the enqueing and dequeing methods (offer, poll, remove() and  add);
    linear time for the remove(Object) and contains(Object) methods; 
    and constant time for the retrieval methods (peek,  element, and size).
    
	public static int findKthLargest(int[] nums, int k) {
        if(nums == null || nums.length == 0){
			return 0;
		}			
		Queue<Integer> q = new PriorityQueue<Integer>();
		for(int n : nums){
		    q.offer(n);
			while(q.size() > k){
			    q.poll();
			}
		}
		return q.poll();
    }
    */


	/*
	The worst case is O(n²) but the likelihood this can happen goes down exponentially because it can only happen if the greatest or least item is chosen as a pivot repeatedly.


	Complexities  Time: O(n)

	On average we will be splitting the input in half leading to a recurrence of T(n) = T(n/2) + (n - 1)

	If we solve for these exact amount of comparisons we see that we stay to the order of linear time.

	Space: O(1)
	*/

	//思路就是求第N最大的， 所以只需要排序部分的就可以了
	public int findKthLargest(int[] nums, int k) {
		int len = nums.length;
		int high = nums.length-1;
		shuffle(nums);
		//最终要找k元素的index
		int finalIndex = len - k;
		int low = 0;



		while(low < high){
			//部分排序一次，看看的出来的INDEX是不是目标INDEX,是的话直接BREAK
			int tmpIndex = partition(nums, low, high);
			if(tmpIndex > finalIndex){
				high = tmpIndex-1;
			}else if(tmpIndex < finalIndex){
				low = tmpIndex+1;
			}else {
				break;
			}
		}

		return nums[finalIndex];
	}

// randomize the input, so that even when the worst case input would be provided the algorithm wouldn't be affected
	public void shuffle (int[] nums){
		Random random = new Random();
		int len = nums.length;
		for(int index = 1; index < len; index++){
			int ran = random.nextInt(index + 1);
			swap(nums, ran, index);
		}
	}

	//排序一次，结果是大于PV的都放在最右边， 小于PV的都放在最左边
	public int partition(int[] nums, int low, int high){
		int l = low;
		int pv = nums[high];
		for(int i = low; i < high; i++){
			if(nums[i] <= pv){
				swap(nums, i, l);
				l++;
			}
		}
		swap(nums, l, high);
		return l;
	}

	public void swap(int[] nums, int a, int b){
		int tmp = nums[a];
		nums[a]  = nums[b];
		nums[b] = tmp;
	}

}



