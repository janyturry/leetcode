/*
Time complexity : O(mn). Each vertex/cell will be calculated once and only once, 
and each edge will be visited once and only once. The total time complexity is then O(V+E).
VV is the total number of vertices and EE is the total number of edges. In our problem, O(V)=O(mn),
O(E) = O(4V) = O(mn)

Space complexity : O(mn). The cache dominates the space complexity.


*/


class Solution {
    int[][] dirs = new int[][]{{1,0}, {-1,0}, {0,-1}, {0,1}};
    public int longestIncreasingPath(int[][] matrix) {
        if(matrix == null || matrix.length < 1 || matrix[0].length < 1){
            return 0;
        }


        int m = matrix.length;
        int n = matrix[0].length;

        int [][]cache = new int[m][n];
        int max = 0;
        for(int i =0 ; i < m; i++){
            for(int j = 0 ; j < n; j++){
                max = Math.max(max , dfs(matrix, cache, i,j));


            }
        }
        return max;


    }

    public int dfs(int[][] matrix, int [][] cache, int i, int j){
        if(cache[i][j] != 0){
            return cache[i][j];
        }

        for(int[] dir :dirs){
            int newX = dir[0] + i;
            int newY = dir[1] + j;
            if(newX >=0 && newX <= matrix.length-1 && newY>=0 && newY < matrix[0].length && matrix[newX][newY] > matrix[i][j]){
                cache[i][j] = Math.max( cache[i][j],dfs(matrix, cache, newX, newY));
            }
        }

        return ++cache[i][j];
    }
}
