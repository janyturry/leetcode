/*
Time Complexity:
For the constructor function, the time complexity would be O(N), which is due to the construction of the prefix sums.

For the pickIndex() function, this time its time complexity would be O(logN), since we did a binary search on the prefix sums.

Space Complexity

For the constructor function, the space complexity remains O(N), which is again due to the construction of the prefix sums.

For the pickIndex() function, its space complexity would O(1), since it uses constant memory. Note, here we consider the prefix sums that it operates on, as the input of the function.
    
    */


class Solution {
    int[] sum;
    Random r;
    
    public Solution(int[] w) {
        for(int i = 1 ; i < w.length; i++){
            w[i] += w[i-1];
        }    
        this.sum = w;
        this.r = new Random();
    }
    
    public int pickIndex() {
        int len = sum.length;
        //nextInt from [0 to x) 
        int idx = r.nextInt(sum[len-1]) + 1 ;
        
        int left = 0;
        int right = sum.length-1;
        
        while(left< right){ 
            int mid = left + (right -  left)/2;
            
            if(sum[mid]  == idx){
                return mid;
                //证明mid不可能是目的index，所以可以直接抛弃
            }else if(sum[mid] < idx){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
       return left;
    }
}






class Solution {
    int [] sum ;
    public Solution(int[] w) {
        sum = new int[w.length];
        int tmpSum = 0;
        for(int i = 0 ; i < w.length; i++){
            tmpSum+=w[i];
            sum[i] = tmpSum;
        }
    }

    public int pickIndex() {
        Random r = new Random();
        //because 1 <= w[i] <= 10^5, so nextInt from [0 to x) , then next from [1 to x+1)
        int next = r.nextInt(sum[sum.length-1]) + 1;
        int left = 0;
        int right =sum.length-1;

        /*
        if you use while (lo <= hi) you use lo=mid+1 and hi=mid-1
        if you use while (lo < hi) you use lo = mid+1 and hi=mid
         */
        while(left < right){
            int mid = left + (right - left)/2;
            if(next == sum[mid]){
                return mid;
            }else if( next < sum[mid]){
                right = mid;
            }else{
                left = mid+1;
            }
        }
        return left;
    }
}

