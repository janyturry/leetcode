
//621. Task Scheduler
//leetcode
/*
partCount = count(A) - 1
emptySlots = partCount * (n - (count of tasks with most frequency - 1))
availableTasks = tasks.length - count(A) * count of tasks with most frenquency
idles = max(0, emptySlots - availableTasks)
result = tasks.length + idles
 */


public class leastInterval {
	public int leastInterval(char[] tasks, int n) {
        int[] counter = new int[26];
        
        int singleSrequentAppearTaskCount = 0;
        int frequentAppearTotal = 0;
        for(char c : tasks){
        	counter[c-'A']++;
        }
        
        for(int i : counter){
        	if(i >= singleSrequentAppearTaskCount){
        		singleSrequentAppearTaskCount = i;
        	}
        }
        
        for(int i : counter){
        	if(i == singleSrequentAppearTaskCount){
        		frequentAppearTotal++;
        	}
        }
        
        int partCount = singleSrequentAppearTaskCount -1;
        int partLength =  n - (frequentAppearTotal - 1);
        int emptySlots = partCount * partLength;
        int availableTasks = tasks.length - singleSrequentAppearTaskCount *frequentAppearTotal;
        /*
        if emptySlots is negative, it means that we even have remaining tasks to make the "distance" between same tasks longer than n. That is, no idle is needed. Thus,
        idles = Math.max(0, emptySlots - availableTasks); is for covering this case.
        */
        int idles = Math.max(0, emptySlots - availableTasks);
        return tasks.length + idles;
        

        
	}
}
