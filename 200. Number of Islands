
import java.util.LinkedList;
import java.util.Queue;
//200. Number of Islands
//leetcode
//BFS 方法
//基本思路就是循环两个for, 遇到==1的，就count++,然后BFS 能接触到的全变成0.count++, 四个方向
public class numIslands {
	class cor {
		int x;
		int y;

		public cor(int a, int b) {
			this.x = a;
			this.y = b;
		}
	}

	int[] dirX = { 1, 0, -1, 0 };
	int[] dirY = { 0, 1, 0, -1 };

	/*
	public int numIslands(char[][] grid) {
		if (grid == null || grid.length == 0 || grid[0] == null
				|| grid[0].length == 0) {
			return 0;
		}

		int m = grid.length - 1;
		int n = grid[0].length - 1;
		int count = 0;

		//要记住这种模式，刚开始放什么东西入栈
		for (int i = 0; i <= m; i++) {
			for (int j = 0; j <= n; j++) {
				if (grid[i][j] == '1') {

					bfs(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	public void bfs(char[][] grid, int x, int y) {
		Queue<cor> q = new LinkedList<cor>();
		q.add(new cor(x, y));
		// 不能忘记这一步
		grid[x][y] = '0';
		while (!q.isEmpty()) {
			int size = q.size();
			for (int i = 0; i < size; i++) {
				cor tmp = q.poll();
				for (int j = 0; j < 4; j++) {
					int newX = tmp.x + dirX[j];
					int newY = tmp.y + dirY[j];
                    //别忘记要检查边界范围
					if (newX >= 0 && newX <= grid.length - 1 && newY >= 0
							&& newY <= grid[0].length - 1
							&& grid[newX][newY] == '1') {
						grid[newX][newY] = '0';
						q.offer(new cor(newX, newY));
					}
				}
			}
		}
	}
	
	*/
	
	//DFS
	  char[][] g;
	   public int numIslands(char[][] grid) {
		   if(grid == null || grid.length ==0 || grid[0] == null || grid[0].length ==0){
			   return 0;
		   }
		   g = grid;
		   int m = grid.length;
		   int n = grid[0].length;
		   int count = 0;
		   
		   for(int i = 0; i < m; i++){
			   for(int j = 0; j < n; j++){
				   if(g[i][j] == '1'){
					   dfs(i, j);
					   count++;
				   }
			   }
		   }
		   return count;
	   }
	   
	   public void dfs(int x, int y){
		   if(x <0 || x >= g.length ||y <0 ||y>= g[0].length || g[x][y] !='1'){
			   return ;
		   }
		   //mart as visited
		   g[x][y] = '0';
		   
		   dfs(x-1,y);
		   dfs(x+1, y);
		   dfs(x,y-1);
		   dfs(x, y+1);
	   }
}
