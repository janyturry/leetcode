
import java.util.LinkedList;
import java.util.Queue;
//200. Number of Islands
//leetcode
//BFS 方法
//基本思路就是循环两个for, 遇到==1的，就count++,然后BFS 能接触到的全变成0.count++, 四个方向
public class numIslands {
	class cor {
		int x;
		int y;

		public cor(int a, int b) {
			this.x = a;
			this.y = b;
		}
	}

	int[] dirX = { 1, 0, -1, 0 };
	int[] dirY = { 0, 1, 0, -1 };

	/*
	public int numIslands(char[][] grid) {
		if (grid == null || grid.length == 0 || grid[0] == null
				|| grid[0].length == 0) {
			return 0;
		}

		int m = grid.length - 1;
		int n = grid[0].length - 1;
		int count = 0;

		//要记住这种模式，刚开始放什么东西入栈
		for (int i = 0; i <= m; i++) {
			for (int j = 0; j <= n; j++) {
				if (grid[i][j] == '1') {

					bfs(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	public void bfs(char[][] grid, int x, int y) {
		Queue<cor> q = new LinkedList<cor>();
		q.add(new cor(x, y));
		// 不能忘记这一步
		grid[x][y] = '0';
		while (!q.isEmpty()) {
			int size = q.size();
			for (int i = 0; i < size; i++) {
				cor tmp = q.poll();
				for (int j = 0; j < 4; j++) {
					int newX = tmp.x + dirX[j];
					int newY = tmp.y + dirY[j];
                    //别忘记要检查边界范围
					if (newX >= 0 && newX <= grid.length - 1 && newY >= 0
							&& newY <= grid[0].length - 1
							&& grid[newX][newY] == '1') {
						grid[newX][newY] = '0';
						q.offer(new cor(newX, newY));
					}
				}
			}
		}
	}
	
	*/
	
	
	
	
	
	
	
	
/*
当以邻接表表示时，查找所有顶点的邻接表所需时间为O(|E|)，访问顶点所需时间为O(|v|)，此时，总的时间复杂度为O(|v|+|E|)。
 */
//DFS
class Solution {
    final static int dir[][] = new int[][]{{-1,0}, {1,0}, {0,-1},{0,1}};
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length <1 || grid[0].length <1){
            return 0;
        }

        int row = grid.length;
        int col = grid[0].length;

        int count = 0;
        for(int i =0 ; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == '1'){
                    count++;
                    dfs(grid, i, j , row, col);
                }
            }
        }
        return count;
    }

    public void dfs (char [][] grid, int i, int j, int row, int col){

        if(i <0 || i >=row || j <0 || j>=col || grid[i][j] == '0'){
            return ;
        }
        //要跟面试官讨论最后要不要恢复矩阵， 要恢复的话，要转换成其他数字，例如'3'
        grid[i][j] = '0';
        for(int[] tmp : dir){

            int newX = tmp[0] + i;
            int newY = tmp[1] + j;
            dfs(grid, newX, newY, row,col);
        }
    }
}


