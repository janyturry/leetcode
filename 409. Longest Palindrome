/*
ans += x - (x & 1);
1 对于任意一个数字x，（x & 1）的结果要么为0，要么为1——取决于x的二进制数的最后一位是0还是1； 2 奇数的二进制数最后一位总是1，偶数的二进制数最后一位总是0； 所以,如果x为偶数，(x & 1)就为0； 如果x为奇数， （x & 1）就为1； --- x表示某个字符出现次数的计数器； 如果某个字符在原始字符串中出现了偶数次，那么这x个字符都可以用来组成回文字符串； 如果出现了奇数次，那就需要去掉其中一个字符，才能保证剩下的字符都可以用来组成回文字符串；

--- 最终，回文字符串的长度 ans += x & (x-1);

----- 但是通过这种方式来组成回文字符串时，忽略了可以放在回文字符串中间位置的字符； 怎么办？

判断上面的处理过程是不是把某个字符忽略掉了，如果是，添加回来，放在回文字符串的中间位置 return ans < s.length() ? ans + 1 : ans;

*/

class Solution {
    public int longestPalindrome(String s) {
        if(s == null ){
            return 0;
        }
        
        int[] count = new int[58];
        
        int res = 0;
        for(char c: s.toCharArray()){
            count[c-'A']++;
        }
        
        for(int i : count){
            res+= i - (i&1);
        }
        //  如果最终的长度小于原字符串的长度，说明里面某个字符出现了奇数次，那么那个字符可以放在回文串的中间，所以额外再加一。
        return res< s.length()? res+1 : res;
    }
}
