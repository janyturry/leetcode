class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] temp = new int[26];
        int countMaxTask = 0;
        int maxTask=0;
        for(char c:tasks){
            temp[c-'A']++;
            maxTask = Math.max(temp[c-'A'],maxTask);
        }
        for(int i=0;i<26;i++){
            if(temp[i]==maxTask){
                countMaxTask++;
            }
        }
	//因为(maxTask-1)*(n+1)+countMaxTask 只计算N的捅宽度之内的情况， 所以要考虑两者之间的最大值
        return Math.max(tasks.length,(maxTask-1)*(n+1)+countMaxTask);
    }
}
