/*
The match process uses i for query pointer and j for pattern pointer, each iteration;

If current char query[i] matches pattern[j], increase pattern pointer;
if does not match and query[i] is lowercase, keep going;
if does not match and query[i] is captalized, we should return false.
If this pattern matches, j should equal length of pattern at the end.

*/

class Solution {
    public List<Boolean> camelMatch(String[] queries, String pattern) {
        List<Boolean> res = new LinkedList<>();
        for(String s : queries){
            boolean  flag = isMatch(s.toCharArray(), pattern.toCharArray());
            res.add(flag);
        }
        return res;
    }
    
    public boolean isMatch(char[] query, char[] pat){
        int j = 0; 
        for(int i = 0 ; i< query.length; i++) {
            if( j < pat.length && query[i] == pat[j]){
                j++;
           }else if((query[i] >='A' && query[i] <='Z' ))
                {
                return false;
            }else{
                
            }
        }
        return j == pat.length;
    } 
}
                     
                     
