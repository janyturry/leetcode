package test;

import java.util.LinkedList;

//239. Sliding Window Maximum
//leetcode
//peek(): the head (first element) of this list.
//poll(): Retrieves and removes the head (first element) of this list.
//peekLast(): Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
//pollLast(): Retrieves and removes the last element of this list, or returns null if this list is empty.
//Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
//Output: [3,3,5,5,6,7]
//思路： 先建立结果集合，然后一直从左往右scan, 链表头一直存放最大的数，然后首先检查链表头是不是out of window, then check current elemetn , comapre with end of list
//if less, the poll the last element.
public class maxSlidingWindow {
	public static int[] maxSlidingWindow(int[] nums, int k) {
		int n = nums.length;
		if (n == 0) {
			return nums;
		}
		int[] result = new int[n - k + 1];
		LinkedList<Integer> dq = new LinkedList<>();
		for (int i = 0; i < n; i++) {
			//check if head out of the range of K
			if (!dq.isEmpty() && dq.peek() < i - k + 1) {
				dq.poll();
			}
			
			//check if last element smaller or equal than the current element 
			while (!dq.isEmpty() && nums[i] >= nums[dq.peekLast()]) {
				dq.pollLast();
			}
			dq.offer(i);
			//check if dp 到达 需要长度，就可以开始计算
			if (i - k + 1 >= 0) {
				result[i - k + 1] = nums[dq.peek()];
			}
		}
		return result;
	}


	public static void main(String[] argc){
		int[] test =  {1,3,-1,-3,5,3,6,7};
		
		maxSlidingWindow(test ,2);
		
	    System.out.println("aaa");
    }
}
