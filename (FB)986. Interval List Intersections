//two pointer
/*
Time Complexity: O(M + N), where M,N are the lengths of A and B respectively.

Space Complexity: O(M + N), the maximum size of the answer.
*/

//关键在于判断是否++, 是要看那一段intervel的end point 是不是最小，如果是最小的那么他肯定已经不可能跟B 继续inter, 所以++
class Solution {
    public int[][] intervalIntersection(int[][] A, int[][] B) {
        if(A ==null || A.length < 1 ||A[0] == null || A[0].length < 1 ||
         B ==  null || B.length < 1 || B[0] == null || B[0].length < 1){
		return new int[0][0];
	}

	int i = 0 ;
	int j  =0;

	List<int[]> res= new LinkedList<>();
	while( i < A.length && j < B.length){

		int lo = Math.max(A[i][0], B[j][0]);
		int hi = Math.min(A[i][1], B[j][1]);

		if(lo <=hi){
		    res.add(new int[]{lo, hi});
		}		
/*
交集区间的产生，不一定是俩俩子区间产生的，一个子区间可能和多个子区间产生重叠
因此在指针移动时，要做个简单的判断
*/
		if(A[i][1] <= B[j][1]){
			i++;
		}else{
			j++;
		}
	}

	return res.toArray(new int[res.size()][2]);

    }
}
