//560. Subarray Sum Equals K
//leetcode


import java.util.Map;

//solution 1 : native
class Solution {

    //native
    public static int subarraySum(int[] nums, int k) {
        int  len = nums.length;
        int  count = 0;
        for(int i = 0 ; i < len; i++){
            for(int j = i; j < len; j++){
                int tmpSum = 0;
                for(int p = i; p <=j; p++){
                    tmpSum+= nums[p];

                }
                if(tmpSum == k){
                    count++;
                }
            }
        }
        return count;
    }



    //solution 2: using preSum
    public int subarraySum(int[] nums, int k) {
        int  len = nums.length;
        int  count = 0;
        for(int i = 0 ; i < len; i++){
            int tmpSum = 0;
            for(int j = i; j < len; j++){
                tmpSum+=nums[j];

                if(tmpSum == k){
                    count++;
                }
            }
        }
        return count;
    }



    //solution 3 : Linear Solution
    /*
    using the prefixSum array of the original input
    prefixSum[x] = sum of subarry (0,x) = num[0] + num[1] +....+nums[x]


    index :           0 1 2
    nums =           [1,1,1]
    preFixSum: =    0 1 2 3               preFixSum [x] = preFixSum[x-1] + nums[x]

    HashMap:      {<0,1>, <1,1>, <2,1>, <3,1>}


    sum of  subarray(i,j) = prefixSum[j] - prefixSum[i-1]

    prefixSum[j]   =   nums[0] + nums[1] + .... +nums[i-1] + num[i] + ....+ nums[j]
    prefixSum[i-1] =   nums[0] + nums[1] + .... + nums[i-1]
    eg: sum of subarray(1,2) = prefixSum[2] - prefixSum[0]

    fix how many paris of <i,j>
    where i < j, prefixSum[j] - prefixSum[i] == k?

    idea:
    for each k:
            how many i < j satisfies prefixSum[i] = prefixSum[j] -k

    using a hashmap<Integer, Integer> to record:
            key : prefixSum value
            value: # of occurrence of the prefixSum value

            time : O(n)

*/


    //Time complexity O(n), Space complexity O(n).
    public int subarraySum(int[] nums, int k) {
        if(nums == null || nums.length < 1){
            return 0;
        }

        Map<Integer, Integer> map = new HashMap<>();

        int preFixSum = 0;
        int count = 0;
        /*
        "Those (sum - k) == 0 calculations" actually means the subarrays that begins at index 0 with sum == k. That is, it's for handling the corner cases at index 0.
Since the hashmap solution is indeed to subtract subarray(0, j) with subarray(0,i-1), "preSum.put(0, 1)" is just for the corner case when i = 0.
We did the same in brute force O(n^2) solution. We let sums.size() = n+1 and sums[0] = 0.
From this point of view, I think "preSum.put(0, 1)" is easier to understand than "if (sum == k) count++;" .
         */
        map.put(0,1);
        for(int tmp : nums){
            preFixSum+=tmp;
            count+= map.getOrDefault(preFixSum- k, 0);

            map.put(preFixSum, map.getOrDefault(preFixSum,0) + 1);

        }

        return count;



    }

    public static void main(String[] argc){
        int[] test = new int[]{1,1,1};


        System.out.println(subarraySum(test, 2));
    }
}



